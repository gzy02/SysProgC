#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include "compile.h"
#include "set.h"


// prototypes
static void compile_exp(Exp_t exp);
static void compile_stm(Stm_t stm);


static char instr[1024];
static int local_fd = 1;


// emit instructions
void emit(char *s){
    write(local_fd, s, strlen(s));
}

void emit_vars() {
    char *var = 0;
    emit("\n\t.data\n");
    while ((var=set_next())){
        sprintf(instr, "\t.global\t%s\n", var);
        emit(instr);
        emit("\t.align 8\n");
        sprintf(instr,"\t.type\t%s, @object\n", var);
        emit(instr);
        sprintf(instr,"\t.size\t%s, 8\n", var);
        emit(instr);
        sprintf(instr,"%s:\n", var);
        emit(instr);
        emit("\t.quad\t0\n");
    }
}

static void compile_exp(Exp_t exp){
    switch (exp->type) {
        case EXP_NUM:{
            Exp_Num e = (Exp_Num)exp;
            sprintf(instr, "\tmovq $%d, %%rax\n", e->num);
            emit(instr);
            break;
        }
        case EXP_VAR: {
            Exp_Var e = (Exp_Var) exp;
            sprintf(instr, "\tmovq %s(%%rip), %%rax\n", e->name);
            emit(instr);
            break;
        }
        case EXP_ADD: {
            Exp_Add e = (Exp_Add) exp;
            compile_exp(e->left);
            emit("\tpush %rax\n");
            compile_exp(e->right);
            emit("\tpop %rbx\n");
            emit("\taddq %rbx, %rax\n");
            break;
        }
        case EXP_SUB: {
            Exp_Sub e = (Exp_Sub) exp;
            compile_exp(e->left);
            emit("\tpush %rax\n");
            compile_exp(e->right);
            emit("\tpop %rbx\n");
            emit("\tsubq %rbx, %rax\n");
            break;
        }
        case EXP_TIMES: {
            Exp_Times e = (Exp_Times) exp;
            compile_exp(e->left);
            emit("\tpush %rax\n");
            compile_exp(e->right);
            emit("\tpop %rbx\n");
            emit("\timulq %rbx, %rax\n");
            break;
        }
        case EXP_DIV: {
            Exp_Div e = (Exp_Div) exp;
            compile_exp(e->left);
            emit("\tpush %rax\n");
            compile_exp(e->right);
            emit("\tpop %rbx\n");
            emit("\txchg %rax, %rbx\n");
            emit("\tcqto\n");
            emit("\tidivq %rbx\n");
            break;
        }
        default:{
            emit("\t// Unknown expression type\n");
            break;
        }
    }
}

static void compile_stm(Stm_t stm){
    switch (stm->type) {
        case STM_ASSIGN: {
            Stm_Assign s = (Stm_Assign) stm;
            set_add(s->x);
            compile_exp(s->exp);
            sprintf(instr, "\tmovq %%rax, %s(%%rip)\n", s->x);
            emit(instr);
            break;
        }
        case STM_PRINT: {
            Stm_Print s = (Stm_Print) stm;
            compile_exp(s->exp);
            emit("\tmovq %rax, %rsi\n");
            emit("\tleaq mcc_format(%rip), %rdi\n");
            emit("\tcall printf\n");
            break;
        }
        case CMD_SEQ: {
            Stm_Seq s = (Stm_Seq) stm;
            compile_stm(s->left);
            compile_stm(s->right);
            break;
        }
        default: {
            emit("\t// Unknown statement type\n");
            break;
        }
    }
}

// compile a whole program
void compile(Stm_t prog, int fd){
    local_fd = fd;
    set_reset();
    // prolog
    emit("// Auto-generated by mcc. Do not modify.\n");
    emit("\t.file \"input.c\"\n");
    emit("\t.text\n");
    emit("mcc_format: .string \"%d\\n\"\n");
    emit("\t.globl main\n");
    emit("\t.type main, @function\n");
    emit("main:\n");
    // prolog
    emit("\tpushq   %rbp\n");
    emit("\tmovq    %rsp, %rbp\n");
    // program
    compile_stm(prog);
    // epilog
    emit("\tpopq    %rbp\n");
    emit("\tret\n");
    emit_vars();
    // epilog
    emit("// End and bye.\n\n");
    return;
}



